---
source: "https://nadh.in/blog/code-is-cheap/"
clipped: 2026-01-30
---
# Code is cheap. Show me the talk.

TLDR；*软件开发，作为几十年来一直被实践的那套方式，已经结束了。LLM 编码工具从根本上改变了它，至于是更好还是更坏。*

---

> “Talk is cheap. Show me the code.” — Linus Torvalds, August 2000

当 Linux 的创造者 Linus Torvalds 为回应一个关于 Linux 内核复杂编程的说法而抛出这句话时，<sup><a href="https://lkml.org/lkml/2000/8/25/132">[1]</a></sup> 我还是个懵懂、瘦高、刚入门的少年 n00b 程序员，靠拨号上网复制粘贴开源 Perl 和 VB 代码片段。

这句话后来成了软件世界的格言。彼时它的含义是：谈论软件、设想能做什么都很容易，但除非真的投入努力去证明它，否则“说”没什么价值。写出并验证好软件是高投入、高成本、高技能的事业。

即便手握清晰的软件开发计划和精确的实现方法，任何足够复杂的程序，真正写到可用、可靠、且至少能应对未来的程度，都是高投入、繁琐、耗时的。软件开发过程中会出现无数不可预见的复杂性和取舍，<sup><a href="https://lkml.org/lkml/2000/8/26/52">[2]</a></sup> 既有技术的也有外部的。软件架构在中途多次变更并不罕见。仅仅为了“试一试”的成本高到指数级，以至于绝大多数想法根本不会被尝试。

归根结底，瓶颈是老生常谈的人类生理与认知限制——认知带宽、个人时间和资源，最重要的是生理成本：要在不确定的时间里坐着，用双手一行一行地敲出代码，即便它全在脑子里，也要在庞大系统的心智地图里来回切换。若是多人协作，还会叠加一整套人际协调与沟通成本。因此，原型和试验不仅对宏大想法很难，对相对简单的想法也很难。像我们许多人一样，大多数想法会被塞进一个无底的愿望清单里，很可能永远留在那里。过去约 25 年里，我一直这样写程序、做软件，从爱好到关键系统——许多人依赖它们——并且乐在其中。

而如今，这一切当然被彻底扔出了窗外，至于好坏另当别论。

回到 Linus。快进 25 年，他把一段 AI 生成的代码合并到他的玩具项目里，并评论 *“Is this much better than I could do by hand? Sure is.”*，<sup><a href="https://github.com/torvalds/AudioNoise/commit/93a72563cba609a414297b558cb46ddd3ce9d6b5">[3]</a></sup> 我已不再是当年的 n00b，而是满身软件开发伤疤与茧子的人（无论是身体上的还是心理上的），因此能理解其含义。不仅如此，如今我有足够多一手的 LLM 辅助编码经验，不得不说：软件开发，作为几十年来被实践的方式，已经结束了。随之而终结的，还有许多别的东西。

我很清楚这听起来像福山的《历史的终结》，<sup><a href="https://en.wikipedia.org/wiki/The_End_of_History_and_the_Last_Man">[4]</a></sup> 但我还是要重申：

> **软件开发，作为几十年来被实践的方式，已经结束了。**

## I

我很幸运地处在一个过渡的“刚刚好”时代，亲历并参与了互联网与软件版图的迅猛演化——拨号到 DSL 再到千兆；Basic、Visual Basic 4/5/6 和 Delphi；cgi-bin 的兴起与衰落；Altavista 到 Google；XMLHttpRequest 引爆 Web 2.0；Flash 的兴与亡；IE 的退场与 Chrome 的崛起；WAP 到 Symbian 再到 Android 和智能手机应用；SourceForge 的式微与 FOSS（自由与开源软件）的爆炸式扩张与成功；git 和 GitHub；SaaS 的崛起；ExpertsExchange 到 StackOverflow；Linux 世界的壮大；sysadmin 到 devops 再到 whateverOps；Node.js 和 MongoDB 在同一年诞生的阴影；微服务；VC 资助的“独角兽”软件公司的激增；加密与 web3 闹剧；黑暗模式的迅速加深；对隐私、注意力与尊严的系统性榨取；以及软件体积膨胀成为常态。

在这一切过程中，我既是职业开发者，也是涉猎无数语言、框架、工具与方法论的 FOSS 爱好者，一直在写、维护与部署软件。从少年时觉得“缩进很蠢”（尴尬），从复制粘贴到 CVS、svn、再到 git，打过空格与 Tab 的战争，成熟到“各取所需”，如今还会为了省几 KB 去压缩 PNG。我是个涉猎广泛却浅尝辄止的人，是个沉迷者，是个无条件享受写代码与做软件的人。

但现在呢？如今的开发方式，已经不是这些年来那种“对也好错也好、好也好坏也好、容易也好困难也好”的综合体验了。随着代码辅助 LLM 的出现，一切完全被翻转了，我不认为还能回到过去。

这段“雨中泪”的独白挺像那么回事。<sup><a href="https://en.wikipedia.org/wiki/Tears_in_rain_monologue">[5]</a></sup>

## 代码

除了少数显而易见的客观 101 之外，并不存在衡量代码库好坏的通用标准。风格、惯用法、模式、架构千差万别。甚至客观可证的技术选择，也会因取舍而无法达成共识。对我这样的开发者而言，历史上有一些快速评估软件的经验法则。评估一个 FOSS 项目时，我会看一堆因素——客观与主观混合、权重随语境而变——项目的年龄；提交活动是否稀疏或过于疯狂；框架与依赖；代码是否组织一致、注释是否恰当且不至于过度抽象；是否有社区；维护者是否响应；README 是否清晰且让我能快速跑起来；文档质量与深度……

这些经验信号能让人窥见维护者的心智模型、工作方式，以及项目未来可能的走向。比如，精炼的注释、README 与文档意味着体贴、额外努力以及对他人（也对自己）的共情。主要是因为对像我这样的普通开发者而言，文档与测试是必需品，却又枯燥、乏味、维护成本高。

然而，这些观念已被 LLM 迅速而猛烈地掀翻。它们可以一把生成惊艳的文档页面、密不透风（讽刺地说，是迂腐详尽）的 README、漂亮的 UI、规整的代码结构与恰到好处的注释。你不再能判断一个仓库是由从没写过代码的非技术人员“氛围编程”生成的，还是由经验丰富的开发者写就——而开发者是否用了 LLM 更无从得知。这些不再能指示代码质量。相反，越是完美、越是惊艳，就越可疑——是不是低成本的一次性“vibe”编码？

既然这些“代码/软件质量”的经验指标已然死亡，除非更细致地检查和进行一定的专业取证，如今很难分辨麦子与“烂泥”。人们也越来越被迫去更近距离地关注软件的“来源”——谁做的、为何做、历史记录与治理计划。

## 努力

过去，一个不错的开发者要持续投入相当长的时间、经历多轮打磨，才能产出 1 万行高质量代码，不仅有意义、而且可读可维护。虽然代码行数不是质量的指标——往往反过来——但一个高质量的 1 万行代码库，意味着显著的时间、努力、专注、耐心、专业技能，往往还包含项目管理等能力。人类的特质。

如今，LLM 不仅能在数秒内一把生成这些代码，还能处理开发工作流中的许多技术面向，从测试到运维到发布。与疯狂 vibe coding 的不可预测不同，在人类专业能力引导下，产出可以高质量且极其有效。<sup><a href="https://github.com/antirez/flux2.c">[6]</a></sup> 这也是我的亲身体验。我经常把原本要花数周、数月的工作压缩到几天甚至几小时。更重要的是，这并不是靠 vibe coding、AGENT.md，或什么多智能体编排流程，而只是一个 LLM 代理 CLI 在手边。

作为一个有着无底愿望清单的开发者，我用 LLM 工具不仅能快速原型并验证复杂想法，还能写出我主观上认为是“生产级”的高质量软件——在我知道自己该做什么但受限于生理限制时，在我不够清楚需要新想法与新方法时亦是如此。与此同时，我也在学习并加深自己的理解。

为了实现我想要或有能力实现的软件成果，我通常要付出的生理、认知与情绪成本，已经下降了好几个数量级。腾出来的时间和带宽，我现在用来做工程、架构、辩论、折腾、拓展想象力，以及写出更简洁、更有意义、我真正想写的代码。

还记得那句老话，“编程是 90% 思考、10% 打字”吗？现在真的如此了。

## 低质内容

既然代码能被从未写过代码的人在几秒内以工业规模生成，那么代码作为“作品”的*价值*是什么？先不谈明显很差的 LLM 代码，当代码结构规整、功能完备（是的，在恰当引导下 LLM 能写出好代码）时，何为有价值、何为无价值？我们当然不希望现实世界的系统里出现 LLM 生成的代码，而要纯粹的人类代码，对吧？这真是个美妙的笑话。<sup><a href="https://en.wikipedia.org/wiki/2024_CrowdStrike-related_IT_outages">[7]</a></sup> <sup><a href="https://en.wikipedia.org/wiki/Boeing_737_MAX_groundings">[8]</a></sup> <sup><a href="https://en.wikipedia.org/wiki/British_Post_Office_scandal">[9]</a></sup> <sup><a href="https://en.wikipedia.org/wiki/Data_breaches_in_India">[10]</a></sup> <sup><a href="https://en.wikipedia.org/wiki/2017_Equifax_data_breach">[11]</a></sup>

现实是，全球每天由人类写出的绝大多数代码，很可能都接近垃圾。<sup><a href="https://www.it-cisq.org/the-cost-of-poor-quality-software-in-the-us-a-2022-report/">[12]</a></sup> 软件开发甚至[不是一门学科](https://nadh.in/blog/on-software-as-an-indiscipline/)，还远未达到任何客观成熟度。医生和土木工程师要经过严格训练并持证上岗，真实世界的后果与他们的执业资格绑定。那软件开发者与工程师呢？世界运行在粗制滥造、拼凑膨胀的系统上，这些垃圾代码大多由人类写就，而方向往往由缺乏技术素养、缺乏人文学科根基、却握有权力与扭曲激励的人来把控——非技术“技术领导者”的暴政。<sup><a href="https://zerodha.tech/blog/being-future-ready-with-common-sense/#8-the-tyranny-of-non-technical-tech-leaders">[13]</a></sup>

若要挑动情绪，人们甚至会说：AI 垃圾至少排版整洁、文档完善、语法比大多数人写的代码一致。( ͡° ͜ʖ ͡°)

玩笑归玩笑，我并不喜欢 AI 垃圾。阅读那些明显没有灵魂的 LLM 生成信息与文章（在“死掉”的互联网里）<sup><a href="https://nadh.in/blog/decentralised-open-indexes/#quality">[14]</a></sup> 是对杏仁核神经元的浪费——如果还能激活的话。全世界的 LLM 说话与情绪表达在网上变得一模一样，是一种诡异的自我 *Pluribus* 化。<sup><a href="https://en.wikipedia.org/wiki/Pluribus_%28TV_series%29">[15]</a></sup> 没有人类创作——完美与缺陷并存——语言、文学、艺术、音乐等大多不可享受。无限、即时生成的东西，在缺乏人类限制与边界时，很难被珍视。

那么代码也是如此吗？代码与艺术、文学或直接沟通不太一样。代码一直只是手段。和诗歌或散文不同，最终用户并不读也不关心代码。他们不在乎背后的上百个系统用什么语言、框架或架构。代码是被隐藏的。他们通过 UX 与代码的效果和结果互动。说这话时我带着一点不情愿，因为我确实享受写、组织、甚至养护代码。对沉浸其中的人来说，代码带有创造性与艺术性，像我这样的人，对软件常常有些近乎“老顽固”的执念。

如果不考虑明显烂代码，在一个功能性代码泛滥到“好坏难辨”的世界里，究竟是什么让功能性的 AI 代码变成“烂泥”或非“烂泥”？我越来越倾向于认为答案是：责任框架，以及讽刺地说，人的存在感。也就是说，在代码功能等同的情况下，能在至少情感与道德上（有时是法律上）追责某个人，这种可追责性赋予了价值。

当一个开源仓库收到大大的 PR 时，无论质量如何，如果它是人手写的，就会被赋予一种内在价值与对人类时间与努力的共情。人们知道对方支付了真实的生理与认知成本写了大量代码之后才发出 PR。正因如此，这些代码是“昂贵”的，而非廉价。

当一个 PR 明显是 LLM 生成时，无论多好，第一反应往往是“烂泥！”，因为我们无法立刻判断背后是否有人的努力。另一方面，阅读与验证它的成本却不成比例地高——先不谈那些把读代码也交给 LLM 的人。它可能是最好、最正确的代码，但它只是无穷变体中的一个，且生成它几乎没有人类成本与努力。情感上，这感觉是不公与不合理的负担。

而此时，我们的现实已成为另一种版本的博尔赫斯《巴别图书馆》。<sup><a href="https://en.wikipedia.org/wiki/The_Library_of_Babel">[17]</a></sup>

## FOSS

说到“库”，FOSS 可能是人类创造的最伟大的公共共有物。FOSS 及其前身——各种分享代码的机制——可追溯到一个基本前提：软件极其昂贵，需要巨大的专门技能才能创造。世界上只有极少数人具备这种能力，其他人自然只能使用少数人的成果（无论是否专有）。虽然全球开发者生态已经爆炸式增长，但“创造者/使用者”的比例基本不变。大规模的 FOSS 协作与社区动力都源自于此——代码库作为有价值的共享成果。

当代码变得廉价，专家可以快速生成中小规模的库与模块，并完美贴合自身需求，不论多小众，会发生什么？不必是专家，在一个足够聪明的人也能“vibe”出自己私用的小工具并随意定制的世界，这正在四处发生。StackOverflow 的现状<sup><a href="https://futurism.com/artificial-intelligence/ai-has-basically-killed-stack-overflow">[18]</a></sup> 也正在发生在软件上，只是没有那么戏剧化。这似乎直击 FOSS 协作与分享的人类动力、社会条件与激励机制的核心。再加上若考虑即将到来的 FOSS 项目“寒武纪式爆发”，那些仍能存活并繁荣的高质量 FOSS 项目，专业治理、策展与信任可能会变得比代码本身更有价值。

## 只见树木不见森林

没有语法高亮、IDE 或任何工具时，人类也能写出惊艳的软件；而在资源与工具极其丰富的今天，人类照样会产出垃圾。一个有能力、表达清晰、关心质量的开发者，会用 LLM 或其他工具以自己的方式产出高质量成果。一个能力不足、表达不清、缺乏质量意识的开发者，则会产出糟糕的东西——无论有没有 LLM。

因此，狂热“agentic” vibe coding 的极端拥护者<sup><a href="https://github.com/steveyegge/gastown">[19]</a></sup> 与 LLM 的彻底否定者，都没看到重点。现实存在一条务实的中间道路：有经验、有专业能力、能清晰表达的人，可以使用这些工具，以合适的取舍获得想要的结果。

Vibe coding 自有其位置，尤其对非技术人而言，他们第一次可以折腾、探索、玩乐，并用软件赋能自己。我在周围看到的正是如此。然而，这些 vibe coding 的狂热追随者忽略了一个让人类认真对待“产物”的关键——有限性。他们正在生成一个博尔赫斯式的图书馆，最终自己也可能淹没在由谄媚代理制造的“烂泥”海洋中。所谓“烂泥”，不是因为代码质量差，而是因为任何可以无限生成、没有努力成本、没有可靠来源的东西，都很难被珍视与认真对待。人类对无限供给尤其是无限选择并不擅长应对。这并不奇怪，因为我们是生活在有限星球、有限资源、有限寿命中的生物。

而那些否定者，却过不了“难以置信”的论证。<sup><a href="https://en.wikipedia.org/wiki/Argument_from_incredulity">[20]</a></sup> 他们否定 LLM，只因为不喜欢、用不出好结果、预期错误，或是厌倦了它们。但这并不重要，因为确实有相当多人在有效地使用同样的工具，并拥有相反的体验。我就是其中之一。

话虽如此，炒作、狂热与贪婪驱动下的大量愚蠢、有害实现，是不可否认的现实，也是巨大的担忧。AI 商业泡沫或许是史上最大的泡沫之一。FOSS AI 技术的崛起仍令人抱有希望。然而，把糟糕的参与者、糟糕的行为、数据算计与荒唐的实现，与这些技术的根本物理能力——不是理论的，而是日常、被验证、且实用的能力——错误地混为一谈，是不理性的。这也是只见树木不见森林。

## 人类成本

以上都是从一位经验丰富的开发者与工程师视角出发。对被风吹雨打、摔打够了的人而言，这些 AI 技术是极其有效、强大的辅助。

但对刚起步的年轻人呢？如果一个人没有打好基础，没有对系统与软件开发过程形成内在而细致的理解，这些技术就是不可靠、危险的精灵。要代码，它给代码；要改动，它给改动。很快，人就会被困在一个自己不理解其运作方式的代码库里，只能无助地回到精灵那里继续依赖。因为上了瘾、依赖它，那些本可促成基础能力成长的自然机会就不再出现，甚至走向认知衰退。<sup><a href="https://www.media.mit.edu/publications/your-brain-on-chatgpt/">[21]</a></sup> 那么，若整整一代初级工程师从未真正有机会成长为资深工程师，会发生什么？

我个人不在乎极端的 vibe coder、否定者，甚至所谓“烂泥”。我们都会淹没在烂泥的洪流里，而其中会浮现出许多理智、复原与新软件秩序的岛屿。真正的担忧在于：学习者正被剥夺获取专业能力、客观分辨“烂泥”与非“烂泥”的机会。更糟的是，那些有效使用这些工具的经验者，可能会失去以基础方式指导与培养年轻人的动力——这本该是社会演化的自然环节。不仅在软件开发领域，而且在把人的能动性与决策权大规模外包给黑箱上。

## 话语

此时此刻，对一个动手型开发者而言，阅读并批判性评估代码变得比学习语法、逐行敲代码更重要。当然，这仍是一项重要技能，因为能读懂代码来自于你先学会写它。但日常的软件开发工作流已经完全翻转。

能够好好“talk”的资深开发者——也就是能想象、表达、定义问题、架构与工程的人——比不能的人有着巨大的优势，而且远比以往更悬殊。对具体语言、语法与框架的知识——代码——不再是瓶颈。过去的生理限制不再是障碍。用于规模化、即时生成代码的机器如今是商品化、人人可得的，只差一个 [`pip install` 等价物](https://nadh.in/blog/on-powered-by-ai-marketing/#no-you-are-not-missing-out)；不需要特别训练，不需要学习新语言或框架，几乎没有门槛——*只*需要良好的批判性思维与基础的人类技能，以及运转这套机器的胜任力。

传统的软件开发方法论与角色——瀑布<sup><a href="https://en.wikipedia.org/wiki/Waterfall_model">[22]</a></sup> 到敏捷，<sup><a href="https://en.wikipedia.org/wiki/Agile_software_development">[23]</a></sup> 开发到测试，资深到初级——已经发生根本改变，并在快得难以想象、压缩、模糊、迭代的“agentic”回路中融合。软件开发中的人、组织与公共社群的动态，以及共享与协作的人类动机，<sup><a href="https://www.theregister.com/2026/01/21/curl_ends_bug_bounty/">[24]</a></sup> <sup><a href="https://zulip.readthedocs.io/en/latest/contributing/contributing.html#ai-use-policy-and-guidelines">[25]</a></sup> <sup><a href="https://github.com/ghostty-org/ghostty/blob/main/AI_POLICY.md">[26]</a></sup> 都在改变。

有史以来第一次，好的“话语”比好的代码更有价值，而且是指数级的。其影响深远且具颠覆性。这一次，[确实不同](https://nadh.in/blog/this-time-it-feels-different/)。
